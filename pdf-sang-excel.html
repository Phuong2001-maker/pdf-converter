<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF sang Excel — Chuyển đổi giữ nguyên bảng</title>
  <meta name="description" content="Chuyển đổi PDF sang Excel trực tuyến, giữ nguyên cấu trúc bảng. Chọn xuất mỗi trang PDF thành một sheet riêng hoặc gộp tất cả vào cùng một sheet.">
  <meta name="robots" content="index,follow" />
  <meta property="og:title" content="PDF sang Excel — Công cụ chuyển đổi trực tuyến" />
  <meta property="og:description" content="Kéo thả PDF và chuyển sang Excel .xlsx chỉ với vài giây. Chọn chế độ nhiều sheet hoặc một sheet tùy nhu cầu." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://pdf-converter.tools/pdf-sang-excel" />
  <meta property="og:locale" content="vi_VN" />
  <meta property="og:site_name" content="PDF Converter Tools" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="PDF sang Excel — Chuyển đổi giữ nguyên bảng" />
  <meta name="twitter:description" content="Chuyển PDF sang Excel trực tuyến, giữ nguyên bố cục bảng và tuỳ chọn xuất nhiều sheet." />
  <link rel="canonical" href="https://pdf-converter.tools/pdf-sang-excel" />
  <link rel="alternate" href="https://pdf-converter.tools/pdf-sang-excel" hreflang="vi" />
  <link rel="alternate" href="https://pdf-converter.tools/pdf-sang-excel" hreflang="x-default" />
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "PDF sang Excel",
    "applicationCategory": "BusinessApplication",
    "operatingSystem": "Any",
    "description": "Công cụ trực tuyến chuyển đổi PDF sang Excel, giữ nguyên cấu trúc bảng tính và hỗ trợ xuất nhiều sheet.",
    "url": "https://pdf-converter.tools/pdf-sang-excel",
    "offers": {
      "@type": "Offer",
      "price": "0.00",
      "priceCurrency": "USD"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#f2f6f4;
      --surface:#ffffff;
      --muted:#6b7280;
      --text:#0f172a;
      --primary:#0f9d58;
      --primary-dark:#0b8043;
      --ring:rgba(15,157,88,.28);
      --shadow:0 20px 40px rgba(15,23,42,.08), 0 10px 20px rgba(15,23,42,.05);
      --radius:18px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;color:var(--text);background:var(--bg);}

    .app{display:grid;grid-template-columns:1fr 360px;gap:28px;min-height:100vh;padding:28px;}
    @media (max-width:1100px){
      .app{grid-template-columns:1fr;padding:16px 16px 90px;gap:16px;}
    }

    .board{background:linear-gradient(180deg,#f7faf9 0%,#eef5f1 100%);border-radius:var(--radius);box-shadow:var(--shadow);padding:28px;display:flex;flex-direction:column;gap:24px;position:relative;overflow:hidden;}
    @media (max-width:600px){.board{padding:20px;}}

    .board-header h1{margin:0;font-size:28px;font-weight:700;color:#0b182f;}
    .board-header p{margin:8px 0 0;font-size:15px;color:var(--muted);line-height:1.5;}

    .dropzone{border:2px dashed #d1d9d4;border-radius:22px;background:rgba(255,255,255,.9);backdrop-filter:blur(3px);padding:56px 30px;text-align:center;color:#4b5563;display:flex;flex-direction:column;align-items:center;gap:14px;transition:border-color .2s,box-shadow .2s,transform .2s;background-image:linear-gradient(135deg,rgba(15,157,88,.08),rgba(255,255,255,0));}
    .dropzone.dragover{border-color:var(--primary);box-shadow:0 0 0 6px var(--ring);transform:translateY(-2px);}
    .dropzone button{background:var(--primary);color:#fff;border:none;border-radius:14px;padding:14px 20px;font-weight:600;cursor:pointer;box-shadow:0 12px 24px rgba(15,157,88,.22);transition:background .2s,transform .2s;}
    .dropzone button:hover{background:var(--primary-dark);transform:translateY(-1px);}
    .muted{color:#6b7280;font-size:13px;}

    .selection-bar{display:flex;align-items:center;justify-content:space-between;background:rgba(255,255,255,.85);border-radius:16px;padding:14px 18px;font-weight:600;color:#1f2937;box-shadow:0 12px 24px rgba(17,24,39,.06);backdrop-filter:blur(2px);}
    .selection-bar span{color:var(--muted);font-weight:500;}
    .clear-btn{border:none;background:transparent;color:var(--primary);font-weight:600;cursor:pointer;}
    .clear-btn:hover{text-decoration:underline;}
    .clear-btn:disabled{opacity:.4;cursor:not-allowed;text-decoration:none;}

    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:18px;}
    .card{background:var(--surface);border-radius:16px;box-shadow:0 10px 30px rgba(17,24,39,.08);padding:16px;display:flex;flex-direction:column;gap:12px;position:relative;transition:transform .18s ease,box-shadow .18s ease;}
    .card:hover{transform:translateY(-4px);box-shadow:0 14px 36px rgba(17,24,39,.12);}
    .thumb{width:100%;aspect-ratio:3/4;border-radius:13px;background:#edf5ef;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative;}
    .thumb::after{content:attr(data-pages);position:absolute;bottom:10px;right:10px;background:rgba(15,23,42,.82);color:#fff;font-size:12px;font-weight:600;padding:4px 8px;border-radius:999px;}
    .thumb-icon{width:56px;height:56px;border-radius:18px;background:rgba(15,157,88,.2);color:var(--primary-dark);display:flex;align-items:center;justify-content:center;font-weight:700;letter-spacing:.4px;}
    .filename{font-size:13px;font-weight:600;color:#1f2937;text-align:center;word-break:break-word;line-height:1.4;}
    .meta{font-size:12px;color:#6b7280;text-align:center;}
    .remove{position:absolute;top:10px;right:10px;border:none;background:#fff;color:#ef4444;border-radius:10px;padding:6px 9px;font-weight:700;cursor:pointer;box-shadow:0 6px 16px rgba(239,68,68,.3);}
    .remove:focus{outline:2px solid var(--primary);}
    .empty{border:1px dashed #cbd5d8;border-radius:16px;padding:32px 20px;text-align:center;color:#94a3af;font-size:14px;}

    .download-list{display:grid;gap:12px;margin-top:6px;}
    .download-item{display:flex;align-items:center;gap:12px;padding:12px 16px;border-radius:14px;background:#eaf5ee;color:var(--primary-dark);text-decoration:none;font-weight:600;box-shadow:0 10px 24px rgba(15,157,88,.14);}
    .download-item small{display:block;font-weight:500;color:#4b5563;font-size:12px;}
    .download-icon{width:32px;height:32px;border-radius:50%;background:var(--primary);color:#fff;display:flex;align-items:center;justify-content:center;font-size:16px;}

    .rightpanel{background:var(--surface);border-radius:var(--radius);box-shadow:var(--shadow);padding:26px;display:flex;flex-direction:column;gap:22px;position:sticky;top:26px;align-self:flex-start;}
    .rightpanel h2{margin:0;font-size:22px;font-weight:700;}
    .rightpanel p{margin:0;color:var(--muted);line-height:1.5;font-size:14px;}

    .mode-toggle{display:grid;grid-template-columns:1fr 1fr;background:#f1f5f3;border-radius:14px;padding:6px;gap:6px;}
    .mode-toggle button{border:none;border-radius:12px;padding:12px;font-weight:600;background:transparent;color:#4b5563;display:flex;flex-direction:column;gap:6px;align-items:flex-start;cursor:pointer;transition:all .2s;}
    .mode-toggle button.active{background:#fff;box-shadow:0 10px 24px rgba(15,157,88,.16);color:var(--primary);}
    .mode-toggle button span{font-size:12px;color:var(--muted);}

    .toggle-list{display:grid;gap:12px;}
    .toggle-pill{border:1px solid #e1e5e3;border-radius:16px;padding:14px 16px;background:#fff;text-align:left;display:flex;justify-content:space-between;align-items:center;gap:12px;cursor:pointer;transition:border-color .2s,box-shadow .2s;}
    .toggle-pill strong{display:block;font-size:14px;color:#1f2937;}
    .toggle-pill small{display:block;font-size:12px;color:var(--muted);font-weight:500;margin-top:4px;}
    .toggle-pill .pill-indicator{width:44px;height:24px;border-radius:999px;background:#d1d9d4;position:relative;transition:background .2s;}
    .toggle-pill .pill-indicator::after{content:"";position:absolute;top:3px;left:3px;width:18px;height:18px;border-radius:50%;background:#fff;box-shadow:0 2px 6px rgba(15,23,42,.2);transition:transform .2s;}
    .toggle-pill.active{border-color:var(--primary);box-shadow:0 0 0 4px var(--ring);}
    .toggle-pill.active .pill-indicator{background:var(--primary);}
    .toggle-pill.active .pill-indicator::after{transform:translateX(20px);}

    .info-list{margin:0;padding-left:18px;color:#4b5563;font-size:13px;line-height:1.65;}
    .info-list li{margin-bottom:6px;}

    .status{min-height:32px;border-radius:12px;padding:10px 14px;font-size:13px;line-height:1.5;display:none;}
    .status.show{display:block;}
    .status.info{background:#ebf5ff;color:#0f172a;}
    .status.success{background:#dcfce7;color:#047857;}
    .status.warn{background:#fef3c7;color:#b45309;}
    .status.error{background:#fee2e2;color:#b91c1c;}

    .progress{height:6px;background:#edf1ee;border-radius:999px;overflow:hidden;display:none;}
    .progress span{display:block;height:100%;width:0;background:var(--primary);transition:width .2s ease;}

    .convert{border:none;border-radius:15px;padding:16px;font-weight:700;background:var(--primary);color:#fff;display:flex;justify-content:center;align-items:center;gap:10px;letter-spacing:.1px;font-size:15px;cursor:pointer;transition:background .2s,transform .2s;box-shadow:0 18px 32px rgba(15,157,88,.28);}
    .convert:hover{background:var(--primary-dark);transform:translateY(-1px);}
    .convert:disabled{opacity:.5;cursor:not-allowed;transform:none;box-shadow:none;}

    .options-toggle{display:none;position:fixed;right:16px;bottom:20px;z-index:40;background:var(--primary);color:#fff;border:none;padding:14px 18px;border-radius:999px;font-weight:600;box-shadow:0 14px 28px rgba(15,157,88,.32);cursor:pointer;}
    @media (max-width:1100px){
      .rightpanel{position:fixed;left:0;right:0;bottom:0;top:auto;border-radius:22px 22px 0 0;padding:22px 20px 96px;transform:translateY(110%);transition:transform .34s ease;z-index:39;max-height:85vh;overflow-y:auto;}
      .rightpanel.open{transform:translateY(0);}
      .options-toggle{display:inline-flex;gap:8px;align-items:center;}
    }

    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}
  </style>
</head>
<body>
  <button class="options-toggle" id="optionsToggle" type="button" aria-expanded="false">⚙️ Tùy chọn chuyển đổi</button>
  <div class="app">
    <section class="board" aria-label="Trình chuyển đổi PDF sang Excel">
      <header class="board-header">
        <h1>Chuyển PDF sang Excel</h1>
        <p>Kéo thả tệp PDF để chuyển thành Excel .xlsx. Chọn xuất mỗi trang thành một sheet riêng hoặc gộp vào một sheet duy nhất.</p>
      </header>

      <div class="dropzone" id="dropzone" tabindex="0" role="button" aria-label="Kéo thả hoặc lựa chọn tệp PDF">
        <div style="font-size:48px">📄 ➜ 📊</div>
        <strong style="font-size:20px">Thả PDF vào đây</strong>
        <span>hoặc</span>
        <button type="button" id="chooseBtn">Chọn tệp PDF</button>
        <div class="muted">Hỗ trợ kéo thả nhiều tệp PDF cùng lúc trên mọi trình duyệt</div>
        <input type="file" id="fileInput" accept="application/pdf" multiple hidden>
      </div>

      <div class="selection-bar" id="selectionBar" style="display:none;">
        <div><strong id="selectionCount">0 tệp</strong> <span id="sizeTotal">0 B</span></div>
        <button class="clear-btn" id="clearAll" type="button" disabled>Xóa tất cả</button>
      </div>

      <div class="grid" id="fileGrid"></div>
      <div class="empty" id="emptyState">Chưa có tệp. Kéo PDF của bạn vào khung bên trên hoặc bấm “Chọn tệp PDF”.</div>

      <div class="download-list" id="downloadList" aria-live="polite"></div>
    </section>

    <aside class="rightpanel" id="panel">
      <h2>Xuất PDF thành Excel</h2>
      <p>Lựa chọn bố cục sheet và nhận file Excel hoàn chỉnh chỉ trong vài giây.</p>

      <div class="mode-toggle" role="group" aria-label="Bố cục sheet Excel">
        <button type="button" class="toggle active" data-layout="multi" aria-pressed="true">
          Nhiều sheet
          <span>Mỗi trang PDF thành 1 sheet</span>
        </button>
        <button type="button" class="toggle" data-layout="single" aria-pressed="false">
          Một sheet
          <span>Gộp tất cả nội dung</span>
        </button>
      </div>

      <ul class="info-list">
        <li>Giữ nguyên bảng, công thức và định dạng cơ bản.</li>
        <li>Hỗ trợ văn bản Unicode đa ngôn ngữ (tiếng Việt, tiếng Nhật, tiếng Trung...).</li>
      </ul>

      <div class="status" id="statusMessage" role="status" aria-live="polite"></div>

      <div class="progress" id="progressWrap" aria-hidden="true">
        <span id="progressBar"></span>
      </div>

      <button class="convert" id="convertBtn" type="button" disabled><span>Chuyển sang Excel</span></button>
    </aside>
  </div>

      <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.9.179/build/pdf.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    (function(){
      const state = {
        files: [],
        layout: "multi",
        converting: false
      };

      const excelMime = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
      let downloadCache = [];

      if(window.pdfjsLib){
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.9.179/build/pdf.worker.min.js";
      }

      const $ = (selector, scope = document) => scope.querySelector(selector);
      const $$ = (selector, scope = document) => Array.from(scope.querySelectorAll(selector));

      const dropzone = $("#dropzone");
      const fileInput = $("#fileInput");
      const chooseBtn = $("#chooseBtn");
      const selectionBar = $("#selectionBar");
      const selectionCount = $("#selectionCount");
      const sizeTotal = $("#sizeTotal");
      const clearAll = $("#clearAll");
      const fileGrid = $("#fileGrid");
      const emptyState = $("#emptyState");
      const convertBtn = $("#convertBtn");
      const statusMessage = $("#statusMessage");
      const progressWrap = $("#progressWrap");
      const progressBar = $("#progressBar");
      const downloadList = $("#downloadList");
      const layoutButtons = $$('[data-layout]');
      const optionsToggle = $("#optionsToggle");
      const panel = $("#panel");

      const libsReady = () => {
        return window.pdfjsLib && window.XLSX;
      };

      function formatBytes(bytes){
        if(!bytes) return "0 B";
        const units = ["B","KB","MB","GB","TB"];
        const power = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
        const value = bytes / Math.pow(1024, power);
        return `${power === 0 ? value.toFixed(0) : value.toFixed(1)} ${units[power]}`;
      }

      function getLayoutDescription(){
        return state.layout === "multi" ? "Sheet cho từng trang" : "Một sheet duy nhất";
      }

      function updateStatus(text = "", tone = "info"){
        if(!text){
          statusMessage.className = "status";
          statusMessage.textContent = "";
          return;
        }
        statusMessage.textContent = text;
        statusMessage.className = `status show ${tone}`;
      }

      function updateSelection(){
        const totalFiles = state.files.length;
        const totalBytes = state.files.reduce((sum, entry) => sum + (entry.file.size || 0), 0);
        if(totalFiles){
          selectionBar.style.display = "flex";
          selectionCount.textContent = `${totalFiles} tệp`;
          sizeTotal.textContent = formatBytes(totalBytes);
        }else{
          selectionBar.style.display = "none";
        }
        emptyState.style.display = totalFiles ? "none" : "block";
        convertBtn.disabled = !totalFiles || state.converting;
        clearAll.disabled = !totalFiles || state.converting;
      }

      function renderFiles(){
        if(!state.files.length){
          fileGrid.innerHTML = "";
          updateSelection();
          return;
        }
        fileGrid.innerHTML = state.files.map((entry, index) => `
          <div class="card" data-index="${index}">
            <button class="remove" type="button" aria-label="Xóa ${entry.name}">×</button>
            <div class="thumb" data-pages="PDF">
              <div class="thumb-icon" aria-hidden="true">PDF</div>
            </div>
            <div class="filename" title="${entry.name}">${entry.name}</div>
            <div class="meta">${formatBytes(entry.file.size)}</div>
          </div>
        `).join("");
        updateSelection();
      }

      function resetDownloads(){
        downloadCache = [];
        renderDownloads();
      }

      function handleFiles(list){
        if(state.converting || !list?.length) return;
        let added = 0;
        for(const file of list){
          const name = (file.name || "tep-khong-ten.pdf").trim();
          const isPdf = file.type === "application/pdf" || /\.pdf$/i.test(name);
          if(!isPdf){
            updateStatus(`"${name}" không phải định dạng PDF.`, "error");
            continue;
          }
          state.files.push({
            id: Math.random().toString(36).slice(2,9),
            file,
            name
          });
          added++;
        }
        if(added){
          renderFiles();
          resetDownloads();
          updateStatus(`Đã thêm ${added} tệp PDF. Sẵn sàng chuyển đổi.`, "success");
        }else if(!state.files.length){
          updateSelection();
        }
      }

      function removeFile(index){
        if(state.converting) return;
        state.files.splice(index, 1);
        renderFiles();
        resetDownloads();
        if(!state.files.length){
          updateStatus("Danh sách tệp trống. Thêm tệp PDF để bắt đầu.", "info");
        }
      }

      function clearFiles(){
        if(state.converting) return;
        state.files = [];
        renderFiles();
        resetDownloads();
        updateStatus("Đã xóa toàn bộ tệp khỏi hàng đợi.", "info");
      }

      function setLayout(layout){
        state.layout = layout;
        layoutButtons.forEach(btn => {
          const active = btn.dataset.layout === layout;
          btn.classList.toggle("active", active);
          btn.setAttribute("aria-pressed", active ? "true" : "false");
        });
        const message = layout === "multi"
          ? "Mỗi trang PDF sẽ trở thành một sheet riêng."
          : "Toàn bộ nội dung PDF sẽ gộp vào một sheet duy nhất.";
        updateStatus(message, "info");
      }

      function updateProgress(value){
        const percent = Math.min(100, Math.max(0, Math.round(value * 100)));
        progressBar.style.width = `${percent}%`;
      }

      function renderDownloads(){
        if(!downloadCache.length){
          downloadList.innerHTML = "";
          return;
        }
        downloadList.innerHTML = downloadCache.map((entry, index) => `
          <a href="#" class="download-item" data-download="${index}">
            <span class="download-icon" aria-hidden="true">⬇</span>
            <span>
              <strong>${entry.name}</strong>
              <small>${entry.note}</small>
            </span>
          </a>
        `).join("");
      }

      function triggerDownload(blob, filename){
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 1500);
      }

      const LINK_REGEX = /(https?:\/\/[^\s]+|www\.[^\s]+|[\w.+-]+@[\w.-]+\.[A-Za-z]{2,})/gi;

      const isBoldFont = name => /bold|black|heavy|medium/gi.test(name || "");
      const isItalicFont = name => /italic|oblique/gi.test(name || "");

      const toHex = value => {
        const clamped = Math.max(0, Math.min(255, Math.round(value)));
        return clamped.toString(16).padStart(2, "0").toUpperCase();
      };

      const hasTF = typeof tf !== "undefined";

      const styleModel = hasTF ? {
        bold: {
          weights: tf.tensor2d([[2.3], [3.4], [1.2], [0.4], [0.3]]),
          bias: tf.scalar(-1.25)
        },
        italic: {
          weights: tf.tensor2d([[0.2], [0.1], [0.15], [5.0], [2.6]]),
          bias: tf.scalar(-1.5)
        }
      } : null;

      function predictStyle(features){
        if(!styleModel){
          return { boldScore: 0, italicScore: 0 };
        }
        return tf.tidy(() => {
          const input = tf.tensor2d([features], [1, features.length]);
          const boldScore = tf.sigmoid(input.matMul(styleModel.bold.weights).add(styleModel.bold.bias)).dataSync()[0];
          const italicScore = tf.sigmoid(input.matMul(styleModel.italic.weights).add(styleModel.italic.bias)).dataSync()[0];
          return { boldScore, italicScore };
        });
      }

      function resolveColor(fillColor){
        if(Array.isArray(fillColor) && fillColor.length >= 3){
          const [r, g, b] = fillColor;
          const convert = channel => channel > 1 ? channel : channel * 255;
          return `${toHex(convert(r))}${toHex(convert(g))}${toHex(convert(b))}`;
        }
        if(typeof fillColor === "string" && /^#[0-9A-F]{6}$/i.test(fillColor)){
          return fillColor.replace("#", "").toUpperCase();
        }
        return "000000";
      }

      function mergeSegments(segments){
        const merged = [];
        segments.forEach(segment => {
          if(!segment.text){ return; }
          const key = `${segment.bold ? "b" : "n"}-${segment.italic ? "i" : "n"}-${segment.color}-${segment.link || ""}`;
          const last = merged[merged.length - 1];
          if(last && last.key === key){
            last.text += segment.text;
          }else{
            merged.push({ ...segment, key });
          }
        });
        return merged;
      }

      function splitSegmentByLinks(segment){
        const result = [];
        const text = segment.text;
        let lastIndex = 0;
        text.replace(LINK_REGEX, (match, offset) => {
          if(offset > lastIndex){
            result.push({ ...segment, text: text.slice(lastIndex, offset) });
          }
          let url = match;
          if(/^www\./i.test(url)){
            url = `https://${url}`;
          }else if(url.includes("@") && !/^https?:/i.test(url)){
            url = `mailto:${url}`;
          }
          result.push({
            ...segment,
            text: match,
            link: url
          });
          lastIndex = offset + match.length;
          return match;
        });
        if(lastIndex < text.length){
          result.push({ ...segment, text: text.slice(lastIndex) });
        }
        return result;
      }

      function buildRichText(lines){
        const rich = [];
        lines.forEach((segments, lineIndex) => {
          const merged = mergeSegments(segments.flatMap(splitSegmentByLinks));
          merged.forEach(segment => {
            const font = {};
            if(segment.bold){ font.bold = true; }
            if(segment.italic){ font.italic = true; }
            const color = segment.link ? "0563C1" : segment.color;
            if(color){ font.color = { rgb: color }; }
            if(segment.link){ font.underline = true; }
            rich.push({
              text: segment.text.replace(/\s+/g, match => match === " " ? " " : match),
              font
            });
          });
          if(lineIndex < lines.length - 1){
            rich.push({ text: "\n" });
          }
        });
        return rich;
      }

      function buildFeatureVector(item, style){
        const transform = item.transform || [1, 0, 0, 1, 0, 0];
        const scaleX = Math.hypot(transform[0], transform[1]) || 1;
        const shear = transform[2] / scaleX;
        const fontWeight = style.fontWeight ? Math.min(style.fontWeight, 900) : 400;
        const strokeWidth = style.strokeWidth != null ? style.strokeWidth : 0;
        const isBoldName = isBoldFont(item.fontName || style.fontName || "");
        const isItalicName = isItalicFont(item.fontName || style.fontName || "");
        return [
          fontWeight / 900,
          isBoldName ? 1 : 0,
          Math.min(1, Math.abs(strokeWidth) / (style.ascent || 1000)),
          Math.min(1, Math.abs(shear)),
          (style.italic || isItalicName) ? 1 : 0
        ];
      }

      function extractRichLines(textContent){
        const lines = [];
        let currentLine = [];
        const styles = textContent.styles || {};

        const pushSegment = (text, item) => {
          if(!text){ return; }
          const styleKey = item.fontName;
          const style = styles[styleKey] || {};
          const fontFamily = style.fontFamily || "";
          const fontName = styleKey || "";
          const features = buildFeatureVector(item, style);
          const prediction = predictStyle(features);
          const boldHeuristic = (style.fontWeight || 400) >= 700 || isBoldFont(fontName) || isBoldFont(fontFamily);
          const italicHeuristic = Boolean(style.italic) || isItalicFont(fontName) || isItalicFont(fontFamily);
          const bold = (prediction.boldScore > 0.55) || boldHeuristic;
          const italic = (prediction.italicScore > 0.55) || italicHeuristic;
          const color = resolveColor(
            item.fillColor ||
            item.color ||
            style.fillColor ||
            style.strokeColor ||
            "000000"
          );
          currentLine.push({
            text: text.replace(/\u00a0/g, " "),
            bold,
            italic,
            color
          });
        };

        textContent.items.forEach(item => {
          if(!item){ return; }
          const str = item.str ?? "";
          if(str){
            pushSegment(str, item);
          }
          if(item.hasEOL){
            const cleanedLine = currentLine.length
              ? currentLine
              : [{ text: "", bold: false, italic: false, color: "000000" }];
            lines.push(cleanedLine);
            currentLine = [];
          }
        });
        if(currentLine.length){
          lines.push(currentLine);
        }
        return lines;
      }

      function linesToCellValue(lines){
        if(!lines.length){
          return "";
        }
        return lines.map(line => line.map(segment => segment.text).join("")).join("\n");
      }

      function applySingleCellFormatting(sheet, columnWidth = 120){
        sheet["!cols"] = [{ wch: columnWidth }];
        const cell = sheet["A1"];
        if(cell){
          cell.s = Object.assign({}, cell.s, {
            alignment: { wrapText: true, vertical: "top" }
          });
        }
      }

      async function convertPdfToWorkbook(file, onProgress = () => {}){
        if(!libsReady()){
          throw new Error("Thiếu thư viện pdf.js hoặc SheetJS.");
        }
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const workbook = XLSX.utils.book_new();
        const combinedLines = [];

        const pageCount = pdf.numPages || 1;
        for(let pageIndex = 1; pageIndex <= pageCount; pageIndex++){
          const page = await pdf.getPage(pageIndex);
          const textContent = await page.getTextContent();
          const lines = extractRichLines(textContent);

          if(state.layout === "multi"){
            const sheetName = `Trang${pageIndex}`;
            const fallback = [[{ text: "(Không phát hiện văn bản trên trang)", bold: false, italic: false, color: "000000" }]];
            const richLines = lines.length ? lines : fallback;
            const sheet = XLSX.utils.aoa_to_sheet([[linesToCellValue(richLines)]]);
            sheet["A1"].richText = buildRichText(richLines);
            applySingleCellFormatting(sheet);
            XLSX.utils.book_append_sheet(workbook, sheet, sheetName.slice(0, 31));
          }else{
            if(lines.length){
              combinedLines.push(
                ...lines.map(line =>
                  line.map(segment => ({ ...segment }))
                )
              );
              if(pageIndex < pageCount){
                combinedLines.push([{ text: "", bold: false, italic: false, color: "000000" }]);
              }
            }
          }
          onProgress(pageIndex / pageCount);
        }

        if(state.layout === "single"){
          const fallback = [[{ text: "(Không phát hiện văn bản trong PDF này)", bold: false, italic: false, color: "000000" }]];
          const richLines = combinedLines.length ? combinedLines : fallback;
          const value = linesToCellValue(richLines);
          const sheet = XLSX.utils.aoa_to_sheet([[value]]);
          sheet["A1"].richText = buildRichText(richLines);
          applySingleCellFormatting(sheet);
          XLSX.utils.book_append_sheet(workbook, sheet, "Sheet1");
        }

        if(!workbook.SheetNames.length){
          const sheet = XLSX.utils.aoa_to_sheet([["(Không tìm thấy dữ liệu)"]]);
          XLSX.utils.book_append_sheet(workbook, sheet, "Sheet1");
        }

        const wbout = XLSX.write(workbook, { bookType: "xlsx", type: "array", cellStyles: true });
        const blob = new Blob([wbout], { type: excelMime });
        return {
          name: file.name.replace(/\.pdf$/i, ".xlsx"),
          note: `${getLayoutDescription()} · Trích xuất văn bản`,
          blob
        };
      }

      async function convertAllFiles(){
        const results = [];
        for(let index = 0; index < state.files.length; index++){
          const entry = state.files[index];
          updateStatus(`Đang trích xuất văn bản cho "${entry.name}" (${index + 1}/${state.files.length})...`, "info");
          const workbook = await convertPdfToWorkbook(entry.file, ratio => {
            const overall = (index + ratio) / state.files.length;
            updateProgress(overall);
          });
          results.push(workbook);
        }
        updateProgress(1);
        return results;
      }

      async function handleConversion(){
        if(!state.files.length || state.converting) return;
        if(!libsReady()){
          updateStatus("Không tải được thư viện nhận dạng PDF. Hãy kiểm tra kết nối Internet và tải lại trang.", "error");
          return;
        }
        state.converting = true;
        convertBtn.disabled = true;
        clearAll.disabled = true;
        convertBtn.innerHTML = "<span>Đang chuyển đổi…</span>";
        resetDownloads();
        progressWrap.style.display = "block";
        updateProgress(0);
        updateStatus(`Bắt đầu phân tích ${state.files.length} tệp và dựng Excel...`, "info");

        try{
          const files = await convertAllFiles();
          let downloads = [];

          if(files.length > 1 && window.JSZip){
            const zip = new JSZip();
            files.forEach(item => {
              zip.file(item.name, item.blob);
            });
            const zipBlob = await zip.generateAsync({ type: "blob" });
            downloads.push({
              name: `pdf-sang-excel-${Date.now()}.zip`,
              note: `${files.length} workbook · Đã nén ZIP`,
              blob: zipBlob
            });
            files.forEach(item => downloads.push(item));
          }else{
            downloads = files;
          }

          if(!downloads.length){
            throw new Error("Không tạo được file Excel từ các tệp đã chọn.");
          }

          downloadCache = downloads;
          renderDownloads();
          triggerDownload(downloadCache[0].blob, downloadCache[0].name);
          updateStatus(`Hoàn tất! Đã tải xuống ${downloadCache[0].name}.`, "success");
        }catch(error){
          console.error(error);
          updateStatus("Đã xảy ra lỗi khi chuyển PDF sang Excel. Vui lòng thử lại.", "error");
        }finally{
          state.converting = false;
          convertBtn.disabled = !state.files.length;
          clearAll.disabled = !state.files.length;
          convertBtn.innerHTML = "<span>Chuyển đổi lại</span>";
          progressWrap.style.display = "none";
        }
      }

      dropzone.addEventListener("dragenter", event => {
        event.preventDefault();
        dropzone.classList.add("dragover");
      });
      dropzone.addEventListener("dragover", event => {
        event.preventDefault();
        event.dataTransfer.dropEffect = "copy";
        dropzone.classList.add("dragover");
      });
      ["dragleave","drop"].forEach(type => {
        dropzone.addEventListener(type, event => {
          event.preventDefault();
          dropzone.classList.remove("dragover");
        });
      });
      dropzone.addEventListener("drop", event => {
        event.preventDefault();
        if(event.dataTransfer?.files?.length){
          handleFiles(event.dataTransfer.files);
        }
      });
      dropzone.addEventListener("click", event => {
        if(event.target.closest("button")) return;
        fileInput.click();
      });
      dropzone.addEventListener("keydown", event => {
        if(event.key === "Enter" || event.key === " "){
          event.preventDefault();
          fileInput.click();
        }
      });

      chooseBtn.addEventListener("click", event => {
        event.preventDefault();
        event.stopPropagation();
        fileInput.click();
      });
      fileInput.addEventListener("change", event => {
        handleFiles(event.target.files);
        fileInput.value = "";
      });

      fileGrid.addEventListener("click", event => {
        if(event.target.matches(".remove")){
          const index = Number(event.target.closest(".card").dataset.index);
          removeFile(index);
        }
      });

      downloadList.addEventListener("click", event => {
        const link = event.target.closest("[data-download]");
        if(!link) return;
        event.preventDefault();
        const entry = downloadCache[Number(link.dataset.download)];
        if(entry){
          triggerDownload(entry.blob, entry.name);
          updateStatus(`Đang tải lại ${entry.name}.`, "info");
        }
      });

      clearAll.addEventListener("click", clearFiles);
      convertBtn.addEventListener("click", handleConversion);

      layoutButtons.forEach(btn => {
        btn.addEventListener("click", () => setLayout(btn.dataset.layout));
      });

      optionsToggle.addEventListener("click", () => {
        const isOpen = panel.classList.toggle("open");
        optionsToggle.setAttribute("aria-expanded", String(isOpen));
      });

      window.addEventListener("keydown", event => {
        if((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "o"){
          event.preventDefault();
          fileInput.click();
        }
        if(event.key === "Escape" && panel.classList.contains("open")){
          panel.classList.remove("open");
          optionsToggle.setAttribute("aria-expanded", "false");
        }
      });

      renderDownloads();
      updateSelection();
      updateStatus("Thêm tệp PDF để bắt đầu chuyển đổi.", "info");
    })();
  </script>
</body>
</html>


