<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Xếp Ảnh Collage</title>
  <style>
    :root{
      --bg:linear-gradient(145deg,#f1f4fe 0%,#ffffff 40%,#f8fbff 100%);
      --card:#ffffff;
      --subcard:#f6f8ff;
      --text:#1c2430;
      --muted:#596172;
      --primary:#4c85ff;
      --primary-soft:rgba(76,133,255,.18);
      --border:#d9deeb;
      --border-strong:#b8c2db;
      --shadow:0 20px 50px rgba(24,40,80,.12);
      --radius:22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:"Inter","Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      color:var(--text);
      background:var(--bg);
    }
    .app{
      min-height:100vh;
      padding:32px clamp(16px,3vw,52px);
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .workspace{
      width:100%;
      max-width:1260px;
      display:grid;
      grid-template-columns:minmax(0,1.9fr) minmax(0,1.1fr);
      gap:28px;
    }
    .panelShell{
      background:var(--card);
      border-radius:var(--radius);
      border:1px solid rgba(255,255,255,.65);
      box-shadow:var(--shadow);
      position:relative;
    }
    .canvasPanel{
      padding:24px;
      display:flex;
      flex-direction:column;
    }
    .canvasWrap{
      flex:1;
      aspect-ratio:4/5;
      min-height:460px;
      position:relative;
      border-radius:20px;
      border:1px solid var(--border);
      background: repeating-conic-gradient(#e7ebfa 0% 25%, transparent 0% 50%) 50%/26px 26px,#f5f7ff;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    .canvasWrap canvas{
      width:100%;
      height:100%;
      border-radius:inherit;
      display:block;
    }
    .canvasWrap.has-images{
      border-color:#c8d1ec;
      background:#f7f9ff;
    }
    .canvasDrop{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:14px;
      border:2px dashed var(--border-strong);
      border-radius:inherit;
      background:rgba(255,255,255,.9);
      backdrop-filter:blur(12px);
      color:var(--muted);
      text-align:center;
      padding:34px;
      cursor:pointer;
      transition:all .25s ease;
      z-index:3;
    }
    .canvasWrap.has-images .canvasDrop{
      opacity:0;
      pointer-events:none;
      transform:scale(.97);
    }
    .canvasDrop svg{width:62px;height:62px;fill:var(--primary);}
    .canvasDrop strong{font-size:22px;color:var(--text);}
    .canvasDrop p{margin:0;font-size:14px;max-width:300px;line-height:1.55;}
    .canvasDrop.is-drag{
      border-color:var(--primary);
      box-shadow:0 0 0 8px var(--primary-soft);
      transform:scale(1.02);
    }
    #file{display:none;}

    .optionsPanel{
      padding:22px 24px 26px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .optionsHeader{
      display:flex;
      align-items:center;
      gap:12px;
      margin-bottom:18px;
    }
    .optionsTitle{
      margin:0;
      font-size:18px;
      font-weight:700;
      color:#1a2130;
      flex:1;
    }
    .options-toggle{
      display:none;
      align-items:center;
      gap:8px;
      padding:10px 14px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#f4f6ff;
      color:#1a2130;
      font-weight:600;
      cursor:pointer;
    }
    .addBtn{
      border:0;
      border-radius:12px;
      padding:10px 16px;
      background:var(--primary);
      color:#fff;
      font-weight:600;
      display:inline-flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      box-shadow:0 12px 26px rgba(76,133,255,.3);
    }
    .addBtn span{font-size:18px;line-height:1;}

    .optionsBody{
      flex:1;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:20px;
    }
    .toolbar{
      display:flex;
      flex-wrap:wrap;
      gap:18px;
    }
    .controlCard{
      flex:1 1 240px;
      background:var(--subcard);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.8);
      padding:18px 20px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .controlCard label{
      font-weight:600;
      font-size:14px;
      letter-spacing:.01em;
      text-transform:uppercase;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .controlValue{color:var(--primary);font-variant-numeric:tabular-nums;font-weight:600;}
    .sliderWrap{display:flex;align-items:center;gap:14px;}
    .sliderWrap input[type="range"]{flex:1;appearance:none;height:6px;border-radius:999px;background:#d7dcf1;outline:none;}
    .sliderWrap input[type="range"]::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:var(--primary);border:2px solid #fff;box-shadow:0 4px 12px rgba(76,133,255,.35);cursor:pointer;}
    .sliderWrap input[type="range"]::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:var(--primary);border:2px solid #fff;box-shadow:0 4px 12px rgba(76,133,255,.35);cursor:pointer;}
    .backgroundPicker{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
    .swatch{width:38px;height:38px;border-radius:12px;border:2px solid transparent;background-size:cover;background-position:center;cursor:pointer;transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;}
    .swatch:hover{transform:translateY(-1px);}
    .swatch.active{border-color:var(--primary);box-shadow:0 0 0 4px var(--primary-soft);}
    .colorInput{width:42px;height:42px;border-radius:14px;border:1px dashed var(--border-strong);overflow:hidden;position:relative;}
    .colorInput input[type="color"]{position:absolute;inset:0;width:100%;height:100%;border:0;padding:0;background:none;cursor:pointer;}
    .collections{
      flex:1;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:18px;
      overflow-y:auto;
      padding-right:4px;
    }
    .thumbStrip{
      display:flex;
      gap:14px;
      overflow-x:auto;
      padding-bottom:6px;
    }
    .thumb{
      position:relative;
      width:132px;
      height:100px;
      border-radius:16px;
      overflow:hidden;
      border:1px solid #dbe1f5;
      background:#fff;
      flex:0 0 auto;
      box-shadow:0 8px 22px rgba(31,58,102,.1);
    }
    .thumb img{width:100%;height:100%;object-fit:cover;display:block;}
    .thumb .rm{position:absolute;top:8px;right:8px;border:0;border-radius:50%;width:28px;height:28px;background:rgba(21,28,45,.78);color:#fff;font-size:16px;cursor:pointer;display:flex;align-items:center;justify-content:center;}
    .thumb .handle{position:absolute;bottom:8px;left:8px;padding:4px 9px;background:rgba(255,255,255,.88);border-radius:999px;font-size:12px;font-weight:600;color:#111c2b;cursor:grab;box-shadow:0 4px 14px rgba(0,0,0,.12);}

    .panelBlock{
      background:var(--subcard);
      border-radius:18px;
      padding:18px 20px 20px;
      border:1px solid rgba(255,255,255,.85);
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .panelBlock.is-empty{display:none;}
    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
    }
    .panelHeader h3{margin:0;font-size:16px;font-weight:700;color:#1a2130;}
    .countTabs{display:flex;flex-wrap:wrap;gap:8px;}
    .countTabs .tab{border:1px solid #d3dbf2;border-radius:999px;padding:6px 14px;background:#fff;font-weight:600;font-size:14px;color:#33405b;cursor:pointer;transition:all .2s ease;}
    .countTabs .tab.active{background:var(--primary);border-color:var(--primary);color:#fff;box-shadow:0 8px 18px rgba(76,133,255,.38);}
    .presetRow{display:flex;gap:12px;overflow-x:auto;padding-bottom:4px;}
    .preset{min-width:138px;border:0;border-radius:18px;background:#fff;border:1px solid transparent;box-shadow:0 12px 28px rgba(41,57,98,.12);padding:12px 12px 14px;cursor:pointer;display:flex;flex-direction:column;gap:10px;transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;}
    .preset:hover{transform:translateY(-2px);}
    .preset.active{border-color:var(--primary);box-shadow:0 18px 34px rgba(76,133,255,.28);}
    .presetCanvas{width:120px;height:120px;border-radius:14px;display:block;}
    .presetLabel{margin:0;font-size:13px;color:#39445a;font-weight:600;}

    .footer{padding-top:14px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;}
    .btn{
      appearance:none;
      border:0;
      border-radius:16px;
      padding:12px 22px;
      background:var(--primary);
      color:#fff;
      font-weight:600;
      font-size:15px;
      cursor:pointer;
      display:inline-flex;
      gap:8px;
      align-items:center;
      box-shadow:0 14px 32px rgba(76,133,255,.35);
      transition:transform .15s ease, box-shadow .2s ease;
    }
    .btn:hover{transform:translateY(-1px);box-shadow:0 18px 38px rgba(76,133,255,.4);}
    .btn:disabled, .btn.disabled{opacity:.45;cursor:not-allowed;box-shadow:none;transform:none;}

    .optionsOverlay{
      position:fixed;
      inset:0;
      background:rgba(13,20,33,.38);
      backdrop-filter:blur(2px);
      opacity:0;
      pointer-events:none;
      transition:opacity .25s ease;
      z-index:10;
    }
    .optionsOverlay.active{opacity:1;pointer-events:auto;}\n    body.options-open{overflow:hidden;}

    @media (max-width:1100px){
      .workspace{grid-template-columns:minmax(0,1.7fr) minmax(0,1fr);}
      .canvasWrap{min-height:480px;}
    }
    @media (max-width:820px){
      .app{padding:26px 16px 32px;}
      .workspace{grid-template-columns:1fr;grid-template-rows:auto auto;gap:20px;}
      .canvasPanel{padding:20px;}
      .canvasWrap{aspect-ratio:3/4; min-height:380px;}
      .optionsPanel{padding:20px;position:relative;}
      .options-toggle{display:inline-flex;}
      .optionsPanel .optionsBody{display:none;animation:fadeIn .2s ease forwards;}
      .optionsPanel.is-open .optionsBody{display:flex;}
      .optionsPanel.is-open{z-index:15;}
    }
    @media (max-width:560px){
      .canvasWrap{aspect-ratio:3/4; min-height:320px;}
      .toolbar{gap:14px;}
      .controlCard{flex:1 1 100%;padding:16px;}
      .preset{min-width:150px;}
      .thumb{width:118px;height:92px;}
      .optionsTitle{font-size:17px;}
      .addBtn{padding:9px 14px;}
    }
    @keyframes fadeIn{from{opacity:0;transform:translateY(-6px);}to{opacity:1;transform:translateY(0);} }
  </style>
</head>
<body>
  <div class="app">
    <section class="workspace">
      <div class="panelShell canvasPanel">
        <div class="canvasWrap" id="canvasWrap">
          <label class="canvasDrop" id="drop" for="file">
            <input id="file" type="file" accept="image/*" multiple />
            <svg viewBox="0 0 64 64" aria-hidden="true">
              <path d="M32 6a14 14 0 0 0-14 14c0 .7.05 1.4.15 2.08A14.97 14.97 0 0 0 6 36c0 8.28 6.72 15 15 15h25a12 12 0 0 0 3-23.6A14 14 0 0 0 32 6zm0 4a10 10 0 0 1 9.85 11.55 2 2 0 0 0 1.66 2.32A8 8 0 0 1 44 32a8 8 0 0 1-8 8h-4v-9h5a1 1 0 0 0 .7-1.7l-9-9a1 1 0 0 0-1.4 0l-9 9A1 1 0 0 0 19 31h5v9h-3a11 11 0 0 1-1.7-21.87 2 2 0 0 0 1.65-2.3A10 10 0 0 1 32 10zm-4 22v12h8V32h3.586L32 24.414 24.414 32H28z"/>
            </svg>
            <strong>Tải ảnh lên</strong>
            <p>Kéo thả ảnh vào phần canvas hoặc bấm “+ Thêm ảnh”. Hỗ trợ nhiều ảnh cùng lúc.</p>
          </label>
          <canvas id="preview"></canvas>
        </div>
      </div>

      <aside class="panelShell optionsPanel" id="optionsPanel">
        <div class="optionsHeader">
          <button class="options-toggle" id="optsToggle" type="button" aria-expanded="false">Mở tùy chọn</button>
          <h2 class="optionsTitle">Điều chảnh</h2>
          <button class="addBtn" id="btnAdd" type="button"><span>+</span>Thêm ảnh</button>
        </div>
        <div class="optionsBody" id="optionsBody">
          <div class="toolbar">
            <div class="controlCard">
              <label for="gap">
                Khoảng cách
                <span class="controlValue" id="gapValue">16px</span>
              </label>
              <div class="sliderWrap">
                <input id="gap" type="range" min="0" max="80" step="1" value="16" />
              </div>
            </div>
            <div class="controlCard">
              <label for="radius">
                Bo góc
                <span class="controlValue" id="radiusValue">0px</span>
              </label>
              <div class="sliderWrap">
                <input id="radius" type="range" min="0" max="120" step="1" value="0" />
              </div>
            </div>
            <div class="controlCard">
              <label for="bg">
                Nền
                <span class="controlValue" id="bgLabel">#FFFFFF</span>
              </label>
              <div class="backgroundPicker" id="bgPalette">
                <button type="button" class="swatch active" data-color="#ffffff" style="background:#ffffff;"></button>
                <button type="button" class="swatch" data-color="#f7f4f8" style="background:linear-gradient(135deg,#f7f4f8 0%,#e4d3f4 100%);"></button>
                <button type="button" class="swatch" data-color="#edf5ff" style="background:linear-gradient(135deg,#edf5ff 0%,#c9e1ff 100%);"></button>
                <button type="button" class="swatch" data-color="#fff5ec" style="background:linear-gradient(135deg,#fff5ec 0%,#ffe0c1 100%);"></button>
                <button type="button" class="swatch" data-color="#181d2d" style="background:#181d2d;"></button>
                <div class="colorInput">
                  <input id="bg" type="color" value="#ffffff" aria-label="Chọn màu nền tùy ý" />
                </div>
              </div>
            </div>
          </div>

          <div class="collections">
            <div class="thumbStrip" id="thumbs"></div>

            <div class="panelBlock" id="layoutSection">
              <div class="panelHeader">
                <h3>Bố cục (2–12 ảnh)</h3>
                <div class="countTabs" id="countTabs"></div>
              </div>
              <div class="presetRow" id="presetGrid"></div>
            </div>

            <div class="panelBlock" id="shapeSection">
              <div class="panelHeader">
                <h3>Hình dạng</h3>
              </div>
              <div class="presetRow" id="shapeGrid"></div>
            </div>
          </div>

          <div class="footer">
            <button class="btn" id="btnExport" disabled>Xuất ảnh PNG</button>
          </div>
        </div>
      </aside>
    </section>
  </div>
  <div class="optionsOverlay" id="optionsOverlay"></div>

  <script>
    const els = {
      canvasWrap: document.getElementById('canvasWrap'),
      canvas: document.getElementById('preview'),
      ctx: document.getElementById('preview').getContext('2d'),
      drop: document.getElementById('drop'),
      file: document.getElementById('file'),
      optsToggle: document.getElementById('optsToggle'),
      optionsPanel: document.getElementById('optionsPanel'),
      optionsBody: document.getElementById('optionsBody'),
      optionsOverlay: document.getElementById('optionsOverlay'),
      addBtn: document.getElementById('btnAdd'),
      thumbs: document.getElementById('thumbs'),
      countTabs: document.getElementById('countTabs'),
      presetGrid: document.getElementById('presetGrid'),
      shapeGrid: document.getElementById('shapeGrid'),
      layoutSection: document.getElementById('layoutSection'),
      shapeSection: document.getElementById('shapeSection'),
      gap: document.getElementById('gap'),
      gapValue: document.getElementById('gapValue'),
      radius: document.getElementById('radius'),
      radiusValue: document.getElementById('radiusValue'),
      bgInput: document.getElementById('bg'),
      bgPalette: document.getElementById('bgPalette'),
      btnExport: document.getElementById('btnExport'),
    };

    const state = {
      images: [],
      draggingIndex: null,
      layout: null,
      layoutKey: '',
      countSelected: 2,
      bgColor: '#ffffff',
      optionsOpen: false,
    };

    function updateOptionsVisibility(force){
      const isMobile = window.matchMedia('(max-width: 820px)').matches;
      if(!isMobile){
        state.optionsOpen = true;
        els.optionsPanel.classList.add('is-open');
        els.optsToggle.setAttribute('aria-expanded','true');
        els.optionsOverlay.classList.remove('active');
        document.body.classList.remove('options-open');
        return;
      }
      if(typeof force === 'boolean') state.optionsOpen = force;
      els.optionsPanel.classList.toggle('is-open', state.optionsOpen);
      els.optsToggle.setAttribute('aria-expanded', state.optionsOpen);
      els.optionsOverlay.classList.toggle('active', state.optionsOpen);
      document.body.classList.toggle('options-open', state.optionsOpen);
    }

    function toggleOptions(){ updateOptionsVisibility(!state.optionsOpen); }
    window.addEventListener('resize', ()=> updateOptionsVisibility());
    els.optsToggle.addEventListener('click', toggleOptions);
    els.optionsOverlay.addEventListener('click', ()=> updateOptionsVisibility(false));

    function resizeCanvas(){
      const rect = els.canvasWrap.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      els.canvas.width = w;
      els.canvas.height = h;
      els.canvas.style.width = rect.width + 'px';
      els.canvas.style.height = rect.height + 'px';
      render();
    }
    window.addEventListener('resize', resizeCanvas);

    function addFiles(files){
      if(!files.length) return;
      const tasks = files.map(f => new Promise(res=>{
        const url = URL.createObjectURL(f);
        const img = new Image();
        img.onload = ()=> res({file:f,url,img,zoom:1,offsetX:0,offsetY:0});
        img.src = url;
      }));
      Promise.all(tasks).then(items=>{
        state.images.push(...items);
        renderThumbs();
        render();
      });
    }

    ['dragenter','dragover'].forEach(ev=>{
      els.canvasWrap.addEventListener(ev, e=>{
        e.preventDefault();
        els.drop.classList.add('is-drag');
      });
    });
    ['dragleave','drop'].forEach(ev=>{
      els.canvasWrap.addEventListener(ev, e=>{
        e.preventDefault();
        if(ev === 'dragleave' && !els.canvasWrap.contains(e.relatedTarget)){
          els.drop.classList.remove('is-drag');
        }
        if(ev === 'drop'){
          els.drop.classList.remove('is-drag');
        }
      });
    });
    els.canvasWrap.addEventListener('drop', e=>{
      const files = [...e.dataTransfer.files].filter(f=>/^image\//.test(f.type));
      addFiles(files);
    });
    els.file.addEventListener('change', e=> addFiles([...e.target.files]));
    els.addBtn.addEventListener('click', ()=> els.file.click());

    function renderThumbs(){
      els.thumbs.innerHTML = '';
      state.images.forEach((item, idx)=>{
        const div = document.createElement('div');
        div.className = 'thumb';
        const im = document.createElement('img');
        im.src = item.url;
        div.appendChild(im);
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'rm';
        btn.textContent = '✕';
        btn.title = 'Xóa ảnh';
        btn.onclick = ()=>{
          state.images.splice(idx,1);
          URL.revokeObjectURL(item.url);
          renderThumbs();
          render();
        };
        div.appendChild(btn);
        const handle = document.createElement('div');
        handle.className = 'handle';
        handle.textContent = 'Ảnh ' + (idx + 1);
        handle.draggable = true;
        handle.addEventListener('dragstart', e=>{
          state.draggingIndex = idx;
          e.dataTransfer.effectAllowed = 'move';
        });
        handle.addEventListener('dragend', ()=> state.draggingIndex=null);
        div.addEventListener('dragover', e=> e.preventDefault());
        div.addEventListener('drop', e=>{
          e.preventDefault();
          const from = state.draggingIndex;
          const to = idx;
          if(from == null || from === to) return;
          const [moved] = state.images.splice(from,1);
          state.images.splice(to,0,moved);
          state.draggingIndex = null;
          renderThumbs();
          render();
        });
        div.appendChild(handle);
        els.thumbs.appendChild(div);
      });
      const hasImages = state.images.length > 0;
      els.canvasWrap.classList.toggle('has-images', hasImages);
      // Ensure canvas pixel size follows wrapper size after layout changes
      requestAnimationFrame(resizeCanvas);
      updateExportButton();
    }

    function computeLayoutFromCells(cells, W, H, gap){
      if(!cells) return [];
      return cells.map(c=>({
        x: c.x * W + gap/2,
        y: c.y * H + gap/2,
        w: Math.max(0, c.w * W - gap),
        h: Math.max(0, c.h * H - gap),
        shape: c.shape,
      }));
    }
    function autoGrid(n){
      if(n<=0) return [];
      const cols = Math.ceil(Math.sqrt(n));
      const rows = Math.ceil(n/cols);
      const res=[];
      let k=0;
      for(let j=0;j<rows;j++){
        for(let i=0;i<cols;i++){
          if(k++>=n) break;
          res.push({x:i/cols,y:j/rows,w:1/cols,h:1/rows});
        }
      }
      return res;
    }

    function buildRoundedRectPath(x,y,w,h,r){
      const p = new Path2D();
      p.moveTo(x+r, y);
      p.arcTo(x+w, y, x+w, y+h, r);
      p.arcTo(x+w, y+h, x, y+h, r);
      p.arcTo(x, y+h, x, y, r);
      p.arcTo(x, y, x+w, y, r);
      p.closePath();
      return p;
    }

    function drawImageMasked(ctx, img, rect, radius, imgState, shape){
      const {x,y,w,h}=rect;
      const r=Math.min(radius, w/2, h/2);
      ctx.save();
      let path;
      if(shape && shape.type){
        path = buildShapePath(shape, x,y,w,h,r);
      }
      if(!path){
        path = buildRoundedRectPath(x,y,w,h,r);
      }
      ctx.clip(path);
      const zx = imgState.zoom || 1;
      const iw = img.width, ih = img.height;
      const rectRatio = w/h, imgRatio = iw/ih;
      let drawW, drawH;
      if(imgRatio > rectRatio){
        drawH = h * zx;
        drawW = drawH * imgRatio;
      }else{
        drawW = w * zx;
        drawH = drawW / imgRatio;
      }
      const dx = x + (w-drawW)/2 + (imgState.offsetX||0);
      const dy = y + (h-drawH)/2 + (imgState.offsetY||0);
      ctx.drawImage(img, dx, dy, drawW, drawH);
      ctx.restore();
    }

    function buildShapePath(shape, x,y,w,h,r){
      const p = new Path2D();
      switch(shape.type){
        case 'circle':{
          const size = Math.min(w,h);
          const cx = x + size/2 + Math.max(0,(w-size)/2);
          const cy = y + size/2 + Math.max(0,(h-size)/2);
          p.arc(cx,cy,size/2,0,Math.PI*2);
          return p;
        }
        case 'heart':{
          const size = Math.min(w,h);
          const ox = x + (w-size)/2;
          const oy = y + (h-size)/2;
          const cx = ox + size/2;
          const cy = oy + size*0.55;
          const s = size/2;
          p.moveTo(cx, cy);
          p.bezierCurveTo(cx - s, cy - s, ox, oy + size*0.3, ox + size*0.25, oy + size*0.2);
          p.bezierCurveTo(ox + size*0.38, oy, cx, oy + size*0.22, cx, oy + size*0.38);
          p.bezierCurveTo(cx, oy + size*0.22, ox + size*0.62, oy, ox + size*0.75, oy + size*0.2);
          p.bezierCurveTo(ox + size, oy + size*0.3, cx + s, cy - s, cx, cy);
          p.closePath();
          return p;
        }
        case 'wave':{
          p.moveTo(x, y + h*0.1);
          p.bezierCurveTo(x + w*0.2, y - h*0.1, x + w*0.4, y + h*0.25, x + w*0.55, y + h*0.5);
          p.bezierCurveTo(x + w*0.7, y + h*0.75, x + w*0.85, y + h*0.9, x+w, y + h*0.7);
          p.lineTo(x+w, y+h);
          p.lineTo(x, y+h);
          p.closePath();
          return p;
        }
        case 'star':{
          const size = Math.min(w,h)/2;
          const cx=x+w/2, cy=y+h/2;
          const inner=size*0.5;
          let rot=Math.PI/2*3;
          const step=Math.PI/5;
          p.moveTo(cx, cy - size);
          for(let i=0;i<5;i++){
            p.lineTo(cx + Math.cos(rot)*size, cy + Math.sin(rot)*size);
            rot += step;
            p.lineTo(cx + Math.cos(rot)*inner, cy + Math.sin(rot)*inner);
            rot += step;
          }
          p.lineTo(cx, cy - size);
          p.closePath();
          return p;
        }
        case 'droplet':{
          const size = Math.min(w,h);
          const ox = x + (w-size)/2;
          const oy = y + (h-size)/2;
          const cx=ox+size/2;
          p.moveTo(cx, oy);
          p.bezierCurveTo(ox+size, oy+size*0.28, ox+size*0.82, oy+size*0.78, cx, oy+size);
          p.bezierCurveTo(ox+size*0.18, oy+size*0.78, ox, oy+size*0.28, cx, oy);
          p.closePath();
          return p;
        }
        case 'triangle':{
          p.moveTo(x + w/2, y);
          p.lineTo(x + w, y + h);
          p.lineTo(x, y + h);
          p.closePath();
          return p;
        }
        case 'hexagon':{
          const size = Math.min(w,h)/2;
          const cx = x + w/2, cy = y + h/2;
          for(let i=0;i<6;i++){
            const ang = Math.PI/3*i - Math.PI/6;
            const px = cx + size*Math.cos(ang);
            const py = cy + size*Math.sin(ang);
            if(i===0) p.moveTo(px,py); else p.lineTo(px,py);
          }
          p.closePath();
          return p;
        }
        case 'diamond':{
          p.moveTo(x + w/2, y);
          p.lineTo(x + w, y + h/2);
          p.lineTo(x + w/2, y + h);
          p.lineTo(x, y + h/2);
          p.closePath();
          return p;
        }
        case 'clover':{
          const size = Math.min(w,h)/2;
          const cx = x + w/2, cy = y + h/2;
          const inner = size*0.6;
          p.moveTo(cx, cy - size);
          p.quadraticCurveTo(cx + inner, cy - inner, cx + size, cy);
          p.quadraticCurveTo(cx + inner, cy + inner, cx, cy + size);
          p.quadraticCurveTo(cx - inner, cy + inner, cx - size, cy);
          p.quadraticCurveTo(cx - inner, cy - inner, cx, cy - size);
          p.closePath();
          return p;
        }
        case 'pebble':{
          const cx = x + w/2, cy = y + h/2;
          const rx = w/2, ry = h/2;
          p.ellipse(cx, cy, rx*0.92, ry*0.78, Math.PI/8, 0, Math.PI*2);
          return p;
        }
        case 'pill':{
          const rad = Math.min(w,h)/2;
          p.moveTo(x + rad, y);
          p.lineTo(x + w - rad, y);
          p.arcTo(x + w, y, x + w, y + rad, rad);
          p.lineTo(x + w, y + h - rad);
          p.arcTo(x + w, y + h, x + w - rad, y + h, rad);
          p.lineTo(x + rad, y + h);
          p.arcTo(x, y + h, x, y + h - rad, rad);
          p.lineTo(x, y + rad);
          p.arcTo(x, y, x + rad, y, rad);
          p.closePath();
          return p;
        }
        default:
          return null;
      }
    }

    function render(){
      const gap = parseInt(els.gap.value,10);
      const radius = parseInt(els.radius.value,10);
      els.gapValue.textContent = gap + 'px';
      els.radiusValue.textContent = radius + 'px';
      if(els.bgInput.value.toLowerCase() !== state.bgColor.toLowerCase()){
        els.bgInput.value = state.bgColor;
      }
      const W = els.canvas.width;
      const H = els.canvas.height;
      els.ctx.save();
      els.ctx.setTransform(1,0,0,1,0,0);
      els.ctx.fillStyle = state.bgColor;
      els.ctx.fillRect(0,0,W,H);
      const n = Math.min(state.images.length, state.layout ? state.layout.length : state.images.length);
      let cells;
      if(state.layout && n>0){
        if(n === 1){
          const first = state.layout[0] || {};
          cells = [{x:0,y:0,w:1,h:1,shape:first.shape}];
        }else{
          cells = state.layout.slice(0,n);
        }
      }else{
        cells = autoGrid(n);
      }
      const effectiveGap = n <= 1 ? 0 : gap;
      const rects = computeLayoutFromCells(cells, W, H, effectiveGap);
      rects.forEach((rect, i)=>{
        const img = state.images[i]?.img;
        const sh = cells[i]?.shape;
        if(!img) return;
        drawImageMasked(els.ctx, img, rect, radius, state.images[i], sh);
      });
      els.ctx.restore();
    }

    function drawPresetPreview(canvas, cells){
      const size = 120;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      const ctx = canvas.getContext('2d');
      ctx.save();
      ctx.scale(dpr,dpr);
      ctx.fillStyle = '#1f2535';
      ctx.fillRect(0,0,size,size);
      const gap = 10;
      const rects = computeLayoutFromCells(cells, size, size, gap);
      rects.forEach((rect, idx)=>{
        const shape = cells[idx]?.shape;
        const path = shape && shape.type ? buildShapePath(shape, rect.x, rect.y, rect.w, rect.h, 8) : buildRoundedRectPath(rect.x, rect.y, rect.w, rect.h, 10);
        ctx.fillStyle = 'rgba(173,192,255,.18)';
        ctx.strokeStyle = 'rgba(255,255,255,.58)';
        ctx.lineWidth = 2;
        ctx.fill(path);
        ctx.stroke(path);
      });
      ctx.restore();
    }

    els.canvas.addEventListener('wheel', e=> e.preventDefault(), {passive:false});

    let hoverIndex = -1;
    let isPanning=false;
    let panStart={x:0,y:0};
    function previewRect(){ return els.canvas.getBoundingClientRect(); }
    function locateCell(px,py){
      const gap = parseInt(els.gap.value,10);
      const n = Math.min(state.images.length, state.layout ? state.layout.length : state.images.length);
      let cells;
      if(state.layout && n>0){
        if(n === 1){
          const first = state.layout[0] || {};
          cells = [{x:0,y:0,w:1,h:1,shape:first.shape}];
        }else{
          cells = state.layout.slice(0,n);
        }
      }else{
        cells = autoGrid(n);
      }
      const effectiveGap = n <= 1 ? 0 : gap;
      const rects = computeLayoutFromCells(cells, els.canvas.width, els.canvas.height, effectiveGap);
      for(let i=0;i<rects.length;i++){
        const r=rects[i];
        if(px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h) return i;
      }
      return -1;
    }
    els.canvas.addEventListener('mousemove', e=>{
      const b=previewRect();
      hoverIndex = locateCell((e.clientX-b.left)*(els.canvas.width/b.width),(e.clientY-b.top)*(els.canvas.height/b.height));
    });
    els.canvas.addEventListener('mousedown', e=>{
      if(hoverIndex<0) return;
      isPanning=true;
      panStart={x:e.clientX,y:e.clientY};
      e.preventDefault();
    });
    window.addEventListener('mouseup', ()=> isPanning=false);
    window.addEventListener('mousemove', e=>{
      if(!isPanning || hoverIndex<0) return;
      const it=state.images[hoverIndex];
      it.offsetX += (e.clientX-panStart.x)*(els.canvas.width/previewRect().width);
      it.offsetY += (e.clientY-panStart.y)*(els.canvas.height/previewRect().height);
      panStart={x:e.clientX,y:e.clientY};
      render();
    });

    ['input','change'].forEach(ev=>{
      els.gap.addEventListener(ev, render);
      els.radius.addEventListener(ev, render);
    });

    els.bgInput.addEventListener('input', e=>{
      state.bgColor = e.target.value;
      updateBgPalette();
      render();
    });
    els.bgPalette.addEventListener('click', e=>{
      const btn = e.target.closest('[data-color]');
      if(!btn) return;
      state.bgColor = btn.dataset.color;
      els.bgInput.value = state.bgColor;
      updateBgPalette();
      render();
    });
    function updateBgPalette(){
      [...els.bgPalette.querySelectorAll('.swatch')].forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.color.toLowerCase() === state.bgColor.toLowerCase());
      });
      document.getElementById('bgLabel').textContent = state.bgColor.toUpperCase();
    }

    function updateExportButton(){
      const disabled = state.images.length === 0;
      els.btnExport.disabled = disabled;
    }

    els.btnExport.addEventListener('click', ()=>{
      if(state.images.length === 0) return;
      els.canvas.toBlob(blob=>{
        if(!blob) return;
        const url = URL.createObjectURL(blob);
        const a=document.createElement('a');
        a.href=url;
        a.download = 'collage.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 3000);
      }, 'image/png');
    });

    function setupLayoutPicker(){
      for(let i=2;i<=12;i++){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tab' + (i===state.countSelected ? ' active':'');
        btn.textContent = i;
        btn.addEventListener('click', ()=>{
          if(state.countSelected === i) return;
          state.countSelected = i;
          state.layout = null;
          state.layoutKey = '';
          updateCountTabs();
          renderPresets();
          render();
        });
        els.countTabs.appendChild(btn);
      }
    }
    function updateCountTabs(){
      [...els.countTabs.children].forEach(btn=>{
        btn.classList.toggle('active', Number(btn.textContent) === state.countSelected);
      });
    }
    function syncActive(container, key){
      [...container.children].forEach(child=>{
        child.classList.toggle('active', child.dataset.key === key);
      });
    }
    function createPresetCanvas(cells){
      const canvas=document.createElement('canvas');
      canvas.className='presetCanvas';
      drawPresetPreview(canvas, cells);
      return canvas;
    }

    function renderPresets(){
      els.presetGrid.innerHTML = '';
      const presets = getPresets(state.countSelected);
      presets.forEach((cells, idx)=>{
        const card = document.createElement('button');
        card.type='button';
        card.className='preset';
        const key = `layout-${state.countSelected}-${idx}`;
        card.dataset.key = key;
        if(state.layoutKey === key) card.classList.add('active');
        const canvas = createPresetCanvas(cells);
        card.appendChild(canvas);
        const label=document.createElement('p');
        label.className='presetLabel';
        label.textContent = `Kiểu ${idx+1}`;
        card.appendChild(label);
        card.addEventListener('click', ()=>{
          state.layout = cells.map(c=>({...c}));
          state.layoutKey = key;
          syncActive(els.presetGrid, key);
          syncActive(els.shapeGrid, '');
          render();
        });
        els.presetGrid.appendChild(card);
      });

      const shapePresets = getShapePresets().filter(item=>item.count === state.countSelected);
      els.shapeGrid.innerHTML='';
      if(!shapePresets.length){
        els.shapeSection.classList.add('is-empty');
      }else{
        els.shapeSection.classList.remove('is-empty');
        shapePresets.forEach((item, idx)=>{
          const card=document.createElement('button');
          card.type='button';
          card.className='preset';
          const key = `shape-${state.countSelected}-${idx}`;
          card.dataset.key = key;
          if(state.layoutKey === key) card.classList.add('active');
          const canvas=createPresetCanvas(item.cells);
          card.appendChild(canvas);
          const label=document.createElement('p');
          label.className='presetLabel';
          label.textContent = item.name;
          card.appendChild(label);
          card.addEventListener('click', ()=>{
            state.layout = item.cells.map(c=>({...c}));
            state.layoutKey = key;
            syncActive(els.shapeGrid, key);
            syncActive(els.presetGrid, '');
            render();
          });
          els.shapeGrid.appendChild(card);
        });
      }
    }

    function getPresets(n){
      const grid = (r,c)=>{const a=[]; for(let j=0;j<r;j++)for(let i=0;i<c;i++) a.push({x:i/c,y:j/r,w:1/c,h:1/r}); return a;};
      const headerGrid = (hRatio, rows, cols)=>{
        const a=[{x:0,y:0,w:1,h:hRatio}];
        const y0=hRatio;
        const rh=1-hRatio;
        for(let j=0;j<rows;j++)for(let i=0;i<cols;i++) a.push({x:i/cols,y:y0+j*rh/rows,w:1/cols,h:rh/rows});
        return a;
      };
      const sideGrid = (wRatio, rows)=>{
        const a=[{x:0,y:0,w:wRatio,h:1}];
        const x0=wRatio;
        const rw=1-wRatio;
        for(let j=0;j<rows;j++) a.push({x:x0,y:j/rows,w:rw,h:1/rows});
        return a;
      };
      switch(n){
        case 2: return [
          [{x:0,y:0,w:.5,h:1},{x:.5,y:0,w:.5,h:1}],
          [{x:0,y:0,w:1,h:.5},{x:0,y:.5,w:1,h:.5}],
          [{x:0,y:0,w:.6,h:1},{x:.6,y:0,w:.4,h:1}],
          [{x:0,y:0,w:.4,h:1},{x:.4,y:0,w:.6,h:1}],
        ];
        case 3: return [
          [{x:0,y:0,w:1,h:.6},{x:0,y:.6,w:.5,h:.4},{x:.5,y:.6,w:.5,h:.4}],
          [{x:0,y:0,w:.6,h:1},{x:.6,y:0,w:.4,h:.5},{x:.6,y:.5,w:.4,h:.5}],
          [{x:0,y:0,w:1/3,h:1},{x:1/3,y:0,w:1/3,h:1},{x:2/3,y:0,w:1/3,h:1}],
        ];
        case 4: return [
          grid(2,2),
          headerGrid(.48,1,2),
          headerGrid(.38,2,2),
          sideGrid(.42,3),
        ];
        case 5: return [
          headerGrid(.52,1,4),
          headerGrid(.42,2,2).slice(0,5),
          sideGrid(.4,4),
          [{x:0,y:0,w:.66,h:1},{x:.66,y:0,w:.34,h:.5},{x:.66,y:.5,w:.34,h:.5},{x:0,y:0,w:.33,h:.5},{x:.33,y:0,w:.33,h:.5}],
        ];
        case 6: return [
          grid(2,3),
          grid(3,2),
          headerGrid(.4,2,3),
          sideGrid(.33,4),
        ];
        case 7: return [
          headerGrid(.42,2,3).slice(0,7),
          sideGrid(.34,6).slice(0,7),
          grid(3,3).slice(0,7),
        ];
        case 8: return [
          grid(2,4),
          grid(4,2),
          headerGrid(.36,3,3).slice(0,8),
          sideGrid(.3,7).slice(0,8),
        ];
        case 9: return [
          grid(3,3),
          headerGrid(.33,2,3).slice(0,9),
          sideGrid(.32,8).slice(0,9),
        ];
        case 10: return [
          grid(2,5),
          grid(5,2),
          headerGrid(.3,3,3).slice(0,10),
          sideGrid(.28,9).slice(0,10),
        ];
        case 11: return [
          grid(3,4).slice(0,11),
          headerGrid(.28,3,3).slice(0,11),
          sideGrid(.26,10).slice(0,11),
        ];
        case 12: return [
          grid(3,4),
          grid(4,3),
          headerGrid(.3,3,4),
        ];
        default:
          return [autoGrid(n)];
      }
    }

    function getShapePresets(){
      return [
        {count:2, name:'Hai khung tròn', cells:[{x:0,y:0.05,w:.5,h:.9,shape:{type:'circle'}},{x:.5,y:0.05,w:.5,h:.9,shape:{type:'circle'}}]},
        {count:2, name:'Trái tim & tròn', cells:[{x:0,y:0.05,w:.5,h:.9,shape:{type:'heart'}},{x:.5,y:0.05,w:.5,h:.9,shape:{type:'circle'}}]},
        {count:2, name:'Cánh hoa dôi', cells:[{x:0,y:0.05,w:.5,h:.9,shape:{type:'clover'}},{x:.5,y:0.05,w:.5,h:.9,shape:{type:'clover'}}]},

        {count:3, name:'Ba trái tim', cells:[{x:0,y:.05,w:1/3,h:.9,shape:{type:'heart'}},{x:1/3,y:.05,w:1/3,h:.9,shape:{type:'heart'}},{x:2/3,y:.05,w:1/3,h:.9,shape:{type:'heart'}}]},
        {count:3, name:'Tam giác nghệ thuật', cells:[{x:0,y:0,w:1/3,h:1,shape:{type:'triangle'}},{x:1/3,y:0,w:1/3,h:1,shape:{type:'triangle'}},{x:2/3,y:0,w:1/3,h:1,shape:{type:'triangle'}}]},
        {count:3, name:'Viên sỏi mềm', cells:[{x:0,y:.05,w:1/3,h:.9,shape:{type:'pebble'}},{x:1/3,y:.05,w:1/3,h:.9,shape:{type:'pebble'}},{x:2/3,y:.05,w:1/3,h:.9,shape:{type:'pebble'}}]},

        {count:4, name:'Bốn khung tròn', cells:[{x:0,y:0,w:.5,h:.5,shape:{type:'circle'}},{x:.5,y:0,w:.5,h:.5,shape:{type:'circle'}},{x:0,y:.5,w:.5,h:.5,shape:{type:'circle'}},{x:.5,y:.5,w:.5,h:.5,shape:{type:'circle'}}]},
        {count:4, name:'Lục giác đối xứng', cells:[{x:0,y:0,w:.5,h:.5,shape:{type:'hexagon'}},{x:.5,y:0,w:.5,h:.5,shape:{type:'hexagon'}},{x:0,y:.5,w:.5,h:.5,shape:{type:'hexagon'}},{x:.5,y:.5,w:.5,h:.5,shape:{type:'hexagon'}}]},
        {count:4, name:'Cỏ bốn lá', cells:[{x:0,y:0,w:.5,h:.5,shape:{type:'clover'}},{x:.5,y:0,w:.5,h:.5,shape:{type:'clover'}},{x:0,y:.5,w:.5,h:.5,shape:{type:'clover'}},{x:.5,y:.5,w:.5,h:.5,shape:{type:'clover'}}]},
        {count:4, name:'Pill dọc', cells:[{x:0,y:0,w:.5,h:.5,shape:{type:'pill'}},{x:.5,y:0,w:.5,h:.5,shape:{type:'pill'}},{x:0,y:.5,w:.5,h:.5,shape:{type:'pill'}},{x:.5,y:.5,w:.5,h:.5,shape:{type:'pill'}}]},

        {count:5, name:'Ngôi sao trung tâm', cells:[{x:.25,y:.25,w:.5,h:.5,shape:{type:'star'}},{x:0,y:0,w:.25,h:.25},{x:.75,y:0,w:.25,h:.25},{x:0,y:.75,w:.25,h:.25},{x:.75,y:.75,w:.25,h:.25}]},
        {count:5, name:'Trái tim và viên sỏi', cells:[{x:0,y:0,w:.4,h:1,shape:{type:'heart'}},{x:.4,y:0,w:.3,h:.5,shape:{type:'pebble'}},{x:.7,y:0,w:.3,h:.5,shape:{type:'pebble'}},{x:.4,y:.5,w:.3,h:.5,shape:{type:'pebble'}},{x:.7,y:.5,w:.3,h:.5,shape:{type:'pebble'}}]},

        {count:6, name:'Sóng & cột', cells:[{x:0,y:0,w:.36,h:1,shape:{type:'wave'}},{x:.36,y:0,w:.64,h:1/5},{x:.36,y:.2,w:.64,h:1/5},{x:.36,y:.4,w:.64,h:1/5},{x:.36,y:.6,w:.64,h:1/5},{x:.36,y:.8,w:.64,h:1/5}]},
        {count:6, name:'Bánh viên', cells:(()=>{const a=[]; for(let j=0;j<2;j++)for(let i=0;i<3;i++)a.push({x:i/3,y:j/2,w:1/3,h:1/2,shape:{type:'circle'}}); return a;})()},

        {count:8, name:'Giọt nước trung tâm', cells:[{x:.15,y:0,w:.7,h:1,shape:{type:'droplet'}},{x:0,y:0,w:.15,h:.25},{x:.85,y:0,w:.15,h:.25},{x:0,y:.25,w:.15,h:.25},{x:.85,y:.25,w:.15,h:.25},{x:0,y:.55,w:.15,h:.25},{x:.85,y:.55,w:.15,h:.25},{x:.32,y:.78,w:.36,h:.22}]},

        {count:10, name:'Hàng tròn 2x5', cells:(()=>{const a=[]; for(let j=0;j<2;j++)for(let i=0;i<5;i++) a.push({x:i/5,y:j/2,w:1/5,h:1/2,shape:{type:'circle'}}); return a;})()},

        {count:12, name:'Mạng lưới tròn 3x4', cells:(()=>{const a=[]; for(let j=0;j<3;j++)for(let i=0;i<4;i++) a.push({x:i/4,y:j/3,w:1/4,h:1/3,shape:{type:'circle'}}); return a;})()},
      ];
    }

    (function init(){
      updateOptionsVisibility(false);
      resizeCanvas();
      setupLayoutPicker();
      renderPresets();
      updateBgPalette();
      renderThumbs();
    })();
  </script>
</body>
</html>


